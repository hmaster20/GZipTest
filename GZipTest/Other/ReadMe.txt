
    Чтение файлов большого объема:

    using (var streamReader = new StreamReader(fileName)) //построчное чтение
    {
        string line;
        while ((line = streamReader.ReadLine()) != null)
        {
            // analize line here
            // throw it away if it does not match
        }
    }
	
            foreach (string l in File.ReadLines(path, Encoding.GetEncoding(1251)))
                http://www.cyberforum.ru/csharp-beginners/thread757831.html


    В CLR лимит на один объекта -2 GB, даже в 64 - х битной.
    Можно написать свою обертку, которая будет выделять кусками, а наружу выглядеть почти как обычный массив.
    BigArray<T>, getting around the 2GB array size limit
     В 4.5 можно убрать это ограничение для 64-х битной CLR - gcAllowVeryLargeObjects
     http://msdn.microsoft.com/en-us/library/hh285054(v=vs.110).aspx






    



1. При работе с файловой системой практически бесполезно самому параллелить компрессию.
	Скорее всего скорость упрется в скорость диска.
    Необходимо чтобы сам алгоритм занимался этим.Стандартный GZipStream такого не умеет.
2. Но, можно попрбовать воспользоваться сторонними библиотеками - http://stackoverflow.com/questions/5901225/is-it-safe-to-call-icsharpcode-sharpziplib-in-parallel-on-multiple-threads
    Выполняйте компрессию в MemoryStream, когда закончите сбрасывайте на диск.
	Тогда не упретесь в скорость диска и сможете параллельность использовать.
3. Начать следует с грамотного (строчного, блочного и\или многопоточного) прочтения огромадного файла.
    Остальное приложиться - потоки, очереди, сжатие.



    1. Создаем объект для хранения сжатых данных, с обязательным наличие ключа.
    2. Запускаем чтение файла, после чтения N количества данных стартуем первый поток обработки.И так по кругу, в несколько потоков.
    3. Если свободных поток нет, ждем когда появится первый свободный и ему скармливаем очередную порцию.
    4. Создаем глобальный счетчик, лучше volatile. 
	   В каждом потоке обработки после обработки очередного блока устанавливаем наш ключ объекта хранения (этим счетчиком) и увеличиваем его на 1.
    5. Записываем наш блок в хранилище блоков сжатых данных(словарь или что-то подобное).
    6. После окончания сжатия сортируем получившееся хранилище по ключу, и в итоге мы получим все блоки в том порядке, в каком они были сжаты.
    Вот примерный алгоритм, как я его вижу.
    как нужно выбирать размер памяти, отведенный приложению?
    Думаю, это можно оставить на усмотрение CLR.



	   создание потока на чтение файла по байтам, блоками ? 
       сохраннеие блоков в памяти
       применение многопоточного сжатия для каждого блока
       прогресс сжатия (сначала примитивно в процентах)
       создание потока на запись нового файла *.gz



	
	https://social.msdn.microsoft.com/Forums/en-US/70784fe4-2b89-4d58-ae05-38bff94c3006/how-to-read-big-text-files-in-c-threads?forum=csharplanguage
	http://stackoverflow.com/questions/26010915/unbuffered-output-very-slow

	http://stackoverflow.com/questions/2161895/reading-large-text-files-with-streams-in-c-sharp

	using (FileStream fs = File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
    using (BufferedStream bs = new BufferedStream(fs))
    using (StreamReader sr = new StreamReader(bs))
    {
		string line;
		while ((line = sr.ReadLine()) != null)
		{

		}
	}







  



Решение пункта 2
###################################################################################################################################################
http://stackoverflow.com/questions/155610/how-do-i-specify-the-exit-code-of-a-console-application-in-net

int main(string[] args)
{
      return 0; //or exit code of your choice
}


enum ExitCode : int {
  Success = 0,
  InvalidLogin = 1,
  InvalidFilename = 2,
  UnknownError = 10
}

int Main(string[] args) {
   return (int)ExitCode.Success;
}

//=============================================
int code = 5;
Environment.Exit(code);
//=============================================

[Flags]
enum ExitCodes : int
{
  Success = 0,
  SignToolNotInPath = 1,
  AssemblyDirectoryBad = 2,
  PFXFilePathBad = 4,
  PasswordMissing = 8,
  SignFailed = 16,
  UnknownError = 32
}

Then
(ExitCodes.SignFailed | ExitCodes.UnknownError)

https://msdn.microsoft.com/ru-ru/library/system.environment.exitcode.aspx
Environment.ExitCode 
Для информации: https://social.msdn.microsoft.com/Forums/vstudio/en-US/707e9ae1-a53f-4918-8ac4-62a1eddb3c4a/detecting-console-application-exit-in-c?forum=csharpgeneral
###################################################################################################################################################











==============================================================================================================================

ТРЕБОВАНИЯ!
Написать программу на C#, предназначенную для архивации и разархивации файлов с помощью System.IO.Compression.GzipStream.
Параметры программы, имена исходного и результирующего файлов задаются в командной строке следующим образом:
1.1.	•	для архивации: GZipTest.exe compress [имя исходного файла] [имя архива]
1.2.	•	для разархивации: GZipTest.exe decompress  [имя архива] [имя распакованного файла]
2.	В случае успеха программа возвращает 0, при ошибке  1.
3.	Программа должна эффективно распараллеливать и синхронизировать задачи в многопроцессорной среде
4.	Программа должна обрабатывать файлы, размер которых превышает объем доступной оперативной памяти.
5.	Код должен корректно обрабатывать все исключения
6.	При работе с потоками допускается использовать только стандартные классы и библиотеки из .Net 3.5 
	(исключая ThreadPool, BackgroundWorker, TPL). Ожидается реализация с использованием Thread-ов.
7.	Код программы должен следовать принципам ООП и ООД (читаемость, разбиение на классы и т.д.).
8.	Алгоритм работы программы необходимо описать словами.
9.	Исходники необходимо прислать вместе с проектом Visual Studio.
10.	Дополнительным плюсом будет возможность корректной(!) остановки программы по Ctrl-C.


ОЦЕНКА!
Программа будет оцениваться по следующим критериям:
1. Работоспособность – проверяется на тестовых файлах с размерами от 0 до 32 Gb
2. Правильность выбора алгоритма с точки зрения эффективности – должен быть максимально загружен самый слабый компонент системы (диск/процессор)
3. Знание и умение использовать примитивы синхронизации – должны быть правильно выбраны примитивы для синхронизации потоков, доступа к данным
4. Проработка архитектуры – есть разбиение на классы по принципам ООП и ООД, не должно быть лишних классов, интерфейсов, методов и т.д.
5. Читабельность и понятность кода – код должен быть простым, аккуратным; алгоритм программы должен быть понятен без отладки
6. Грамотная обработка ошибок и нестандартных ситуаций – должна выводиться диагностическая информация, по которой должно быть понятно что произошло без отладки программы.
7. Правильное управления ресурсами – не должно быть утечек неуправляемых ресурсов, а также своевременное уничтожение управляемых ресурсов


